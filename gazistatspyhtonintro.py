# -*- coding: utf-8 -*-
"""GaziStatsPyhtonIntro.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1318I3rbp2FI0N9mnY6L6GQzFS7R9QoD-

![intro.jpg](data:image/jpeg;base64,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)

**Pyhton ile Temel İstatistik**
"""

# Temel kavramlar
# Değişkene değer atama 
x = 5
print(x)

print("Pyhton ile temel istatistik dersine hoşgeldiniz")
print('Pyhton ile temel istatistik dersine hoşgeldiniz')

# Veri türlerine dair
type(x)

x = str(3)    # x will be '3'
y = int(3)    # y will be 3
z = float(3)

print(type(x))
print(type(y))
print(type(z))

# Birden fazla değişken atamaya dair
x, y, z = "Gazi", "İstatistik", "Python"
print(x)
print(y)
print(z)

print(x + y)

"""Genel veri türlerine dair; 

Text Type:	**str**

Numeric Types:	**int, float**, complex

Sequence Types:	**list, tuple**, range

Mapping Type:	**dict**

Set Types:	**set**, frozenset

Boolean Type:	**bool**

Binary Types:	bytes, bytearray, memoryview
"""

print(type(x))
a= "Ozan"
print(type(a))

print(x**2)
x + 5

# Temel aritmetik işlemlere dair 

x = 10

print(x+2)
print(x-2)
print(x*2)
print(x**2)
print(x/2)
print(x//2) 
print(x%2) 

# print("Başka türlü bir yöntem")
z = 5
z += 1 # z = z + 1
print(z)

m = 8
print(type(m))
print(float(m))
print(m)

#Mantıksal İşlemler

t, f = True, False
print(type(t))

t + f

# Değişken çeşitleri ve temel dönüşümler 
my_string = "Gazi İstatistik"
my_string

print(my_string * 2)
print(my_string + " Topluluğu")

"G" in my_string

print(my_string)
print(my_string[4])
print(my_string[4:6])

# Bazı temel string işlemleri
#my_string.upper()
my_string.lower()
# my_string.replace("s", "S")

age = 33
txt = "My name is Ozan, and I am {} years old"
print(txt)
print(txt.format(age))

a = 'Gazi'
b = 'İstatistik'
my_list = ['my', 'list', a, b]
print(my_list)

my_list2 = [1 , 3]
print(my_list2)

my_list3 = [[4,5,6,7], [3,4,5,6]]
print(my_list3)

my_list3[0][3]

liste = [a , b, [4,5,6,7]]
liste
print(liste)
liste[0]

print(range(10))
L = list(range(10))
print(L)
print(type(L))

L3 = [True, "2", 3.0, 4]
[type(item) for item in L3]

my_list
# Listeden tekli seçim yapma
my_list[1]
my_list[-3]
# Listeden birden fazla eleman seçimi
my_list[1:3]
my_list[1:]
my_list[:3]
my_list[:]
# Liste içerisinde liste seçimi
my_list2[1][0]
my_list2[1][:2]

print(my_list)
print(my_list[1])
print(my_list[-3])

#Liste üzerine işlemler 
mylist = [3, 5, 6, 7] 
print(mylist)

print(mylist.index(3))

mylist.append(3)
print(mylist)

mylist.count(3)

print(mylist)
mylist.insert(0, 10)
print(mylist)

mylist2 = [1,5,9,3,6,7,8]
print(mylist2)
mylist2.append("orange")
print(mylist2)

mylist2.insert(1, "orange")
print(mylist2)

# harfler listesi
vowels = ['e', 'a', 'u', 'o', 'i']
print(vowels)
# harfleri sıralama
vowels.sort()

#Sıralı olarak yazdırma
print('Sıralı liste:', vowels)

vowels.sort(reverse=True)
print(vowels)

# Tuple tanımı 

thistuple = ("Gazi", "İstatistik", "Topluluğu")
print(thistuple)
print(type(thistuple))

print(len(thistuple)) # len fonksiyon ile uzunluğu hesaplanabilir

thistuple = ("Gazi",)
print(type(thistuple))

# Tuple tanımına uygun değil !
thistuple = ("İstatistik")
print(type(thistuple))

tuple1 = ("abc", 34, True, 40, "male")
print(tuple1)

print(tuple1[1]) 
print(tuple1[-1])

# Set tanımı
thisset = {"Gazi", "İstatistik", "Pyhton"}
print(thisset)
print(type(thisset))

thisset = {"Gazi", "İstatistik", "Pyhton", "Gazi"}

print(thisset)

thisset[1] # Bu tanım set için uygun değil !

for x in thisset:
  print(x)

thisset.add("Temel")
print(thisset)

thisset.remove("Gazi")
print(thisset)

# Sözlükler (Dictionaries)
thisdict = {
  "okul": "Gazi",
  "bölüm": "İstatistik",
  "yıl": "2021" 
}
print(thisdict)

thisdict = {
  "okul": ["Gazi, Ankara"],
  "bölüm": "İstatistik",
  "yıl": "2021" 
}
print(thisdict)

thisdict = {
  "okul": "Gazi, Ankara",
  "bölüm": "İstatistik",
  "yıl": "2021",
  "yıl": "2020" 
}
print(thisdict)

# thisdict["okul"]
thisdict.get("okul")

thisdict.keys()

"""Daha fazlası için ufak denemeler yapmak adına bu sayfaya bakılabilir 
https://www.w3schools.com/python/python_dictionaries_access.asp

Ayrıca, githubda şöyle bir derleme de var 

https://github.com/ibrahimirdem/turkce-python-kaynaklari#kitaplar

İngilizce temel kaynak olarak şu kitaba çok detaylı olarak bakılabilir 

https://jakevdp.github.io/PythonDataScienceHandbook/

"""

# Gerekli olan kütüphanelerin yüklenmesi
import pandas as pd
import numpy as np
import matplotlib as plt
import seaborn as sns

# Ya da kütüphane içerisinden ilgili aracın yüklenmesi
from scipy import stats

"""Gerekli olabilecek bazı kütüphaneler açısından; 

**Numpy** is a library for working with arrays of data

**pandas** is a fast, powerful, flexible and easy to use open source data analysis and manipulation tool

**Matplotlib** is a library for making graphs

**Seaborn** is a higher-level interface to Matplotlib that can be used to simplify many graphing tasks

**Statsmodels** is a library that implements many statistical techniques

**Scipy** is a library of techniques for numerical and scientific computing
"""

# Listeden array üretmek için numpy kütüphanesi ile 
l = [1,2,3,4]
print(type(l))

print(l)
print(np.array(l, dtype='float32'))

np.linspace(0, 1, 5)

veri = np.array([1, 4, 2, 5, 3, 5])
print(veri)
print(type(veri))
veri.shape

np.mean(l)

x = np.mean(veri)
y = np.median(veri)
# stats.mode(veri)

print(x)
print(y)
print(stats.mode(veri))

# Verinin ortalama etrafındaki davranışı

print(np.var(veri))
print(np.std(veri))

yaş = [5,31,43,48,50,41,7,11,15,39,80,82,32,2,8,6,25,36,27,61,31]

x = np.percentile(yaş, 75)
print(x)

# Belli dağılımlardan rastgele sayı üretimine dair 

# np.random.random((3, 3))
np.random.normal(0, 1, (3, 3))

np.random.randint(0,10)

x = np.random.uniform(0.0, 5.0, 250)

import matplotlib.pyplot as plt
plt.hist(x, 5)
plt.show()

x = np.random.normal(5.0, 1.0, 100000)

plt.hist(x, 100)
plt.show()

# Saçılım grafiği
x = [5,7,8,7,2,17,2,9,4,11,12,9,6]
y = [99,86,87,88,111,86,103,87,94,78,77,85,86]

plt.scatter(x, y)
plt.show()

x = np.random.normal(5.0, 1.0, 1000)
y = np.random.normal(10.0, 2.0, 1000)

plt.scatter(x, y)
plt.show()

# Bir Veri seti yükleyelim
# Dizin de  AnkaraData.xlsx olduğundan emin olmak gerekiyor !
data = pd.read_excel('/content/AnkaraData.xlsx', index_col=0) 
data

data.info()

# Print out the first few rows of the data
print(data.head(10))
print(data.tail())

data.mean()

# Sadece bir tanesi için 

data['Yield'].mean() # median(), min(), max()
data['Yield'].median()
data['Yield'].min()
data['Yield'].max()

print(data.median())

# Veriler hakkında istatistiksel bilgi veren bir başka yöntem ise describe() yöntemidir. 
data.describe()

# Dağılım için bir histogram çizelim
plt.hist(data['drop'], color= "blue")
plt.hist(data["pval"], color = "red")
plt.hist(data["Yield"], color = "black")

# Normal dağılıma uygun bir veri olsaydı eğer ?
np.random.seed(42)
n = 5000
mean_mu1 = 60
sd_sigma1 = 15
data1 = np.random.normal(mean_mu1, sd_sigma1, n)
mean_mu2 = 80
sd_sigma2 = 15
data2 = np.random.normal(mean_mu2, sd_sigma2, n)

plt.figure(figsize=(8,6))
plt.hist(data1, bins=100, alpha=0.5, label="data1")
plt.hist(data2, bins=100, alpha=0.5, label="data2")

plt.boxplot(data["Yield"])
plt.boxplot(data["Yield"], showmeans=True)

#Değişkenler arasındaki ilişkiye bakmak adına 

np.corrcoef(data["Yield"], data["Wdeft"])

# Tüm değişkenler arasındaki korelasyon bakmak için
data.corr()

"""Korelasyon katsayısı 1'e yaklaştıkça ilişki düzeyi artarken, -1'e yaklaştıkça ilişki düzeyi zayıflamaktadır.

Korelasyon katsayısı “-1” ve “+1” arasında değişen değerler alır.

• r= -1 ise tam negatif doğrusal bir ilişki vardır.

• r= +1 ise tam pozitif doğrusal bir ilişki vardır.

• r= 0 ise iki değişken arasında ilişki yoktur.
"""

plt.figure(figsize = (12,6))
sns.heatmap(data.corr(), annot = True)

plt.scatter(data["pval"], data["Yield"])

#Seaborn ile yapsaydık
ax = sns.scatterplot(x='pval', y='Yield', data=data)

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import seaborn as sns; sns.set()
sns.pairplot(data, size=1.5);

"""Daha fazlası için 

https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.html
"""

# Normallik için bir değişkene bakalım
import statsmodels.api as sm
import pylab as py


sm.qqplot(data["Yield"], line ='45')
py.show()

sm.qqplot(data["pval"], line ='45')
py.show()

import seaborn as sns
# sns.set_theme(style="whitegrid")
ax = sns.boxplot(x=data["Yield"])
py.show()
ax = sns.boxplot(x=data["pval"])
py.show()

ax = sns.boxplot(data=data, orient="h", palette="Set2")

data[["Yield", "pval"]]

# İlgili kütüphanelerden gerekli fonksiyonlar
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error

# girdi ve çıktı değişkenlerinin tanımlanması
X, y = data["pval"], data["Yield"]

# Değişkenlerin standard halet getirilmesi

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1, shuffle = False)
print(X_train)
X_test

X_train, X_test, y_train, y_test = np.array(X_train).reshape((-1, 1)), np.array(X_test).reshape((-1, 1)), np.array(y_train).reshape((-1, 1)), np.array(y_test).reshape((-1, 1))

# fit the model
model = LinearRegression()

# Verinin şeklini uygun hale getirmek adına 
# np.array(X_train).reshape((-1, 1))

fit = model.fit(np.array(X_train).reshape((-1, 1)), np.array(y_train).reshape((-1, 1)))

print('intercept:', fit.intercept_)
print('slope:', fit.coef_)

# fit the model
model = LinearRegression(normalize=True)
model.fit(np.array(X_train).reshape((-1, 1)), np.array(y_train).reshape((-1, 1)))
# evaluate the model
yhat = model.predict(np.array(X_test).reshape((-1, 1)))
# evaluate predictions
mae = mean_absolute_error(y_test, yhat)
print('MAE: %.3f' % mae)

print("Score of the train set",model.score(X_train,y_train))
print("Score of the test set",model.score(X_test,y_test))

#Define adjusted R square tanımı

def adj_r2 (X,y,model):
    r_squared = model.score(X,y)
    return(1 - (1-r_squared)*(len(y)-1)/(len(y)-X.shape[1]-1))

print("Adj. R2 of the train set",adj_r2(X_train,y_train,model))
print("Adj. R2 of the test set",adj_r2(X_test,y_test,model))

# alternatif olarak sm.OLS
model = sm.OLS(y, X).fit()
predictions = model.predict(X)

print(model.params)
# Model özet istatistikleri
print(model.summary())

y_pred = model.predict(np.array(X).reshape((-1, 1)))
print('predicted response:', y_pred, sep='\n')

# Model üzerinden hesaplamak da mümkün 
y_pred = fit.intercept_ + fit.coef_ * np.array(X).reshape((-1, 1))
print('predicted response:', y_pred, sep='\n')

# Tamamı ile yola çıkarsak 
print(data.shape)

X_feat = data.drop('Yield', axis=1)
X_feat.shape

y_target = data['Yield']
y_target.shape

from sklearn import preprocessing
# normalize the data attributes
normalized_feat = preprocessing.normalize(X_feat)
print("Normalized Data = ", normalized_feat)

normalized_targ = preprocessing.normalize(np.array(y_target).reshape((-1, 1)))

# alternatif olarak sm.OLS
print(normalized_targ.shape)
print(normalized_feat.shape)
model = sm.OLS(normalized_targ, normalized_feat).fit()
predictions = model.predict(normalized_feat)

print(model.params)
# Model özet istatistikleri
print(model.summary())

X_feat.info()

X_featnew = X_feat[["Etar", "WSIave", "eval"]]
X_featnew.shape

normalized_feat = preprocessing.normalize(X_featnew)
normalized_feat

#Sadece 3ü ile kurulan bir model olsaydı 
model = sm.OLS(normalized_targ, normalized_feat).fit()
predictions = model.predict(normalized_feat)

print(model.params)
# Model özet istatistikleri
print(model.summary())

# Başlangıç adına nerelere bakılabilir ? 
# Olmayan bir paketi kütüphaneyi yüklemek adına ;
!pip install pingouin

"""İstatistik için kullanılabilecek kütüphaneler:

https://www.scipy.org/about.html

https://pingouin-stats.org/

https://www.statsmodels.org/stable/about.html#about-statsmodels


"""

import numpy as np
import pingouin as pg

np.random.seed(123)

x = np.random.normal(size=50)

ax = pg.qqplot(x, dist='norm')

ax = pg.qqplot(y_target, dist='norm')

pg.corr(X_feat["Etar"], y_target, method = "kendall")